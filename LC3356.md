**Breakdown with Explanation 1:**
So this one of the perfectest qs i have come across,the first thing u have to learn for this q is difference array technique now why am i using it here i would want to increment/decrement values over a range and whats the crux of the idea,lets say i have all zeroes array of size 4 and i want to apply +2 to index 0 and 1 what i would efficiently do instead of the unnecessary processing all thru the loop is i would make a difference array and would just do +2 in my 0th index and -2 in my 2nd index(remember the last index is 1 so its just last index in the range+1)how the difference array looks([2,0,-2,0]) now how do i get my actual ans,just take the cumulative sum what happens the diff array becomes([2,2,0,0]) now this is what we exactly wanted right?damn we actually got it thats the beauty of this approach the cumulative sum after the two operations would make the negated part to be correct(here its 0,simply cos -2+2 would be 0 thats why we did -2 in the index exactly just after our range so we can propagate the sums eventually getting our result),so this is damn powerful cos see we only need two O(1) operations instead of scanning through the entire array incase we have multiple queries for every query we have to apply the updation over the entire range again and again,here we just have to traverse the whole array once at the last for cumulative sum part to get our ans all the other operations we perform are constant time ones,so now u can solve the first part of this q which is leetcode 3355 with this,now coming back to this q now see we can just traverse our query applying the difference array technique and see if it becomes 0 remember we have to return the min k possible but if u just try traversing each query applying it repeatedly its going to be a worst case time of m*(m+n)why lets say u have 5 queries first u would apply 1 query then again 1 and 2 and then 1,2,3 so its repeated calc for bigger inputs its going to exceed the time limit,so what can we do think,the intuition that shd strike to u is binary search isn't it quite obvs cos smehow i want to reduce my n factor and remember i want to return the min queries possible so i would just split my search space.

**Conitnuation of Breakdown(For Better Readability):**
and if my mid is making the array zero great but dont forget the prev queries can make it zero too so typical binary search we just set right=mid-1 to look in the left half now incase i dont get it to be zero then typically there is no use of the initial left half anyway it wouldn't give me the ans so i would constrain my search space to left=mid+1 to see my initial right half and at the end my left(left>right exiting condition) is holding my ans so i would return it,so now we have made a damn good progress to make the time logm*(m+n) which is really significant and u would successfully pass all the 630+ testcases..but there is one more addition the king solution to this problem we can actually even cut off the log factor to make it truly linear(isnt it damn)thats where comes line sweep
the crux is why do i need to traverse my queries twice if u see we can just iterate thru our original array and do only the necessary queries for that index sort of think it like dynamic updation only if we needed it,the point is if our index was less than left we dont actually need it now but we would use it for future cos maybe the next query might include it in the range,then if its between then perfect we actually are working in the exact place then if index is more than right then there is no use of processing it remember queries is sorted so we would have already worked for that index,now yea the most imp point is my while loop would run only till my cumulsum+diffarray[index]<nums[index] with k getting incremented at every step,now if the conditions is equal or greater it means its either 0 or negative(this is our goal)by the time it becomes equal we would have already made the array zero even if its greater eventually it means zero(as we have been able to bring it down and the question also clears this doubt in the second sample test case) and yea the while loop u see only if the condition is satisfied it would process thereby making it only the relevant ones are processed and u see we have achieved linear time we just need to traverse the array once and query array traversal at worst case O(m) so in total its O(n+m) a linear time and the perfect soln to this problem so yea literally a lott to learn,go for it and let me know if any doubts...
